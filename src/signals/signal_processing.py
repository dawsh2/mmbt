"""
Signal Processing Module for Trading System

This module provides signal filtering, transformation, and confidence scoring
capabilities to enhance the quality of trading signals.
"""

from typing import Dict, Any, List, Optional, Union, Callable
from abc import ABC, abstractmethod
from collections import deque
import numpy as np
from enum import Enum, auto


class SignalType(Enum):
    """Enumeration of different signal types."""
    BUY = 1
    SELL = -1
    NEUTRAL = 0


class Signal:
    """
    Class representing a trading signal.
    
    This class provides a standardized structure for trading signals
    generated by rules and strategies in the trading system.
    """
    
    def __init__(self, timestamp, signal_type: SignalType, price: float,
                 rule_id: Optional[str] = None, confidence: float = 1.0,
                 metadata: Optional[Dict[str, Any]] = None, symbol: str = 'default'):
        """
        Initialize a trading signal.
        
        Args:
            timestamp: Signal timestamp
            signal_type: Type of signal (BUY, SELL, NEUTRAL)
            price: Price at signal generation
            rule_id: Identifier of the rule that generated the signal
            confidence: Confidence score (0-1)
            metadata: Additional signal metadata
            symbol: Instrument symbol
        """
        self.timestamp = timestamp
        self.signal_type = signal_type
        self.price = price
        self.rule_id = rule_id
        self.confidence = min(max(confidence, 0.0), 1.0)  # Ensure between 0 and 1
        self.metadata = metadata or {}
        self.symbol = symbol

    def copy(self):
        """Create a copy of the signal."""
        return Signal(
            timestamp=self.timestamp,
            signal_type=self.signal_type,
            price=self.price,
            rule_id=self.rule_id,
            confidence=self.confidence,
            metadata=self.metadata.copy() if self.metadata else None,
            symbol=self.symbol
        )

    @classmethod
    def from_numeric(cls, timestamp, signal_value: int, price: float,
                     rule_id: Optional[str] = None, 
                     metadata: Optional[Dict[str, Any]] = None,
                     symbol: str = 'default'):
        """
        Create a Signal object from a numeric signal value (-1, 0, 1).
        
        Args:
            timestamp: Signal timestamp
            signal_value: Numeric signal value (-1, 0, 1)
            price: Price at signal generation
            rule_id: Optional rule identifier
            metadata: Additional signal data
            symbol: Instrument symbol
            
        Returns:
            Signal: A new Signal object
        """
        if signal_value == 1:
            signal_type = SignalType.BUY
        elif signal_value == -1:
            signal_type = SignalType.SELL
        else:
            signal_type = SignalType.NEUTRAL
            
        return cls(timestamp, signal_type, price, rule_id, 1.0, metadata, symbol)


class SignalFilter(ABC):
    """Base class for signal filters."""
    
    @abstractmethod
    def filter(self, signal: Signal, history: Optional[List[Signal]] = None) -> Signal:
        """
        Filter a signal, potentially using history.
        
        Args:
            signal: Input signal to filter
            history: Optional list of historical signals
            
        Returns:
            Signal: Filtered signal
        """
        pass
    
    def reset(self):
        """Reset filter state."""
        pass


class MovingAverageFilter(SignalFilter):
    """Filter signals using a moving average."""
    
    def __init__(self, window_size: int = 5):
        """
        Initialize with window size.
        
        Args:
            window_size: Size of moving average window
        """
        self.window_size = window_size
        self.signal_history = deque(maxlen=window_size)
        
    def filter(self, signal: Signal, history: Optional[List[Signal]] = None) -> Signal:
        """Apply moving average filter to signal."""
        # Add current signal to history
        self.signal_history.append(signal)
        
        # Not enough history to filter
        if len(self.signal_history) < self.window_size:
            return signal
            
        # Calculate average signal value
        avg_value = sum(s.signal_type.value for s in self.signal_history) / len(self.signal_history)
        
        # Create new signal based on average
        if avg_value > 0.3:
            filtered_type = SignalType.BUY
        elif avg_value < -0.3:
            filtered_type = SignalType.SELL
        else:
            filtered_type = SignalType.NEUTRAL
            
        # Clone original signal with new type
        filtered_signal = signal.copy()
        filtered_signal.signal_type = filtered_type
        filtered_signal.confidence = abs(avg_value)  # Use magnitude as confidence
        
        # Add filtering metadata
        filtered_signal.metadata['filtered'] = True
        filtered_signal.metadata['filter_type'] = 'moving_average'
        filtered_signal.metadata['pre_filter_type'] = signal.signal_type
        filtered_signal.metadata['window_size'] = self.window_size
        
        return filtered_signal
    
    def reset(self):
        """Reset filter state."""
        self.signal_history.clear()


class ExponentialFilter(SignalFilter):
    """Filter signals using exponential smoothing."""
    
    def __init__(self, alpha: float = 0.2):
        """
        Initialize with smoothing factor.
        
        Args:
            alpha: Smoothing factor (0-1)
                Higher alpha gives more weight to recent signals
        """
        self.alpha = min(max(alpha, 0.0), 1.0)  # Ensure between 0 and 1
        self.smoothed_value = 0
        self.initialized = False
        
    def filter(self, signal: Signal, history: Optional[List[Signal]] = None) -> Signal:
        """Apply exponential filter to signal."""
        # Get numeric signal value
        signal_value = signal.signal_type.value
        
        # Initialize or update smoothed value
        if not self.initialized:
            self.smoothed_value = signal_value
            self.initialized = True
        else:
            # Apply exponential smoothing formula
            self.smoothed_value = self.alpha * signal_value + (1 - self.alpha) * self.smoothed_value
        
        # Determine filtered signal type
        if self.smoothed_value > 0.3:
            filtered_type = SignalType.BUY
        elif self.smoothed_value < -0.3:
            filtered_type = SignalType.SELL
        else:
            filtered_type = SignalType.NEUTRAL
            
        # Clone original signal with new type
        filtered_signal = signal.copy()
        filtered_signal.signal_type = filtered_type
        filtered_signal.confidence = abs(self.smoothed_value)  # Use magnitude as confidence
        
        # Add filtering metadata
        filtered_signal.metadata['filtered'] = True
        filtered_signal.metadata['filter_type'] = 'exponential'
        filtered_signal.metadata['alpha'] = self.alpha
        filtered_signal.metadata['smoothed_value'] = self.smoothed_value
        filtered_signal.metadata['pre_filter_type'] = signal.signal_type
        
        return filtered_signal
    
    def reset(self):
        """Reset filter state."""
        self.smoothed_value = 0
        self.initialized = False


class KalmanFilter(SignalFilter):
    """Apply Kalman filtering to signals."""
    
    def __init__(self, process_variance: float = 1e-5, measurement_variance: float = 1e-2):
        """
        Initialize Kalman filter parameters.
        
        Args:
            process_variance: Process noise variance (Q)
            measurement_variance: Measurement noise variance (R)
        """
        self.process_variance = process_variance
        self.measurement_variance = measurement_variance
        self.estimated_signal = 0
        self.estimation_error = 1
        self.initialized = False
        
    def filter(self, signal: Signal, history: Optional[List[Signal]] = None) -> Signal:
        """Apply Kalman filter to signal."""
        # Get numeric signal value
        signal_value = signal.signal_type.value
        
        if not self.initialized:
            # First signal initializes the filter
            self.estimated_signal = signal_value
            self.initialized = True
            return signal
            
        # Prediction step
        prediction = self.estimated_signal
        prediction_error = self.estimation_error + self.process_variance
        
        # Update step
        kalman_gain = prediction_error / (prediction_error + self.measurement_variance)
        self.estimated_signal = prediction + kalman_gain * (signal_value - prediction)
        self.estimation_error = (1 - kalman_gain) * prediction_error
        
        # Create new signal based on filtered value
        if self.estimated_signal > 0.3:
            filtered_type = SignalType.BUY
        elif self.estimated_signal < -0.3:
            filtered_type = SignalType.SELL
        else:
            filtered_type = SignalType.NEUTRAL
            
        # Clone original signal with new type
        filtered_signal = signal.copy()
        filtered_signal.signal_type = filtered_type
        filtered_signal.confidence = abs(self.estimated_signal)
        
        # Add filtering metadata
        filtered_signal.metadata['filtered'] = True
        filtered_signal.metadata['filter_type'] = 'kalman'
        filtered_signal.metadata['estimated_value'] = self.estimated_signal
        filtered_signal.metadata['kalman_gain'] = kalman_gain
        filtered_signal.metadata['pre_filter_type'] = signal.signal_type
        
        return filtered_signal
    
    def reset(self):
        """Reset filter state."""
        self.estimated_signal = 0
        self.estimation_error = 1
        self.initialized = False


class SignalTransform(ABC):
    """Base class for signal transformations."""
    
    @abstractmethod
    def transform(self, data):
        """
        Apply transformation to data.
        
        Args:
            data: Input data to transform
            
        Returns:
            Any: Transformed data
        """
        pass


class WaveletTransform(SignalTransform):
    """
    Apply wavelet transform to price data for multi-scale analysis.
    """
    
    def __init__(self, wavelet='db1', level=3):
        """
        Initialize with wavelet type and decomposition level.
        
        Args:
            wavelet: Wavelet type ('db1', 'haar', etc.)
            level: Decomposition level
        """
        self.wavelet = wavelet
        self.level = level
        self.price_history = deque(maxlen=128)  # Need power of 2 for some wavelets
        
    def add_price(self, price):
        """
        Add price to history.
        
        Args:
            price: Price to add
        """
        self.price_history.append(price)
        
    def transform(self, data=None):
        """
        Apply wavelet transform to price history or provided data.
        
        Args:
            data: Optional data to transform (uses price history if None)
            
        Returns:
            list: Wavelet coefficients at different scales
        """
        if data is None:
            data = list(self.price_history)
            
        if len(data) < 16:  # Minimum required for meaningful transform
            return None
            
        try:
            import pywt
            # Perform wavelet decomposition
            coeffs = pywt.wavedec(data, self.wavelet, level=self.level)
            return coeffs
        except ImportError:
            print("PyWavelets not installed. Install with 'pip install PyWavelets'")
            return None
    
    def analyze_trend(self, coeffs=None):
        """
        Analyze trend at different scales.
        
        Args:
            coeffs: Optional pre-computed wavelet coefficients
            
        Returns:
            dict: Trend strength at different scales
        """
        if coeffs is None:
            coeffs = self.transform()
            
        if coeffs is None:
            return None
            
        # Analyze approximation coefficient (lowest frequency)
        approx = coeffs[0]
        
        # Simple trend analysis: compare first and last points
        trend = approx[-1] - approx[0]
        
        # Calculate trend strength at each level
        detail_trends = {}
        for i, detail in enumerate(coeffs[1:], 1):
            # Measure the power in the detail coefficients
            power = np.sum(np.square(detail))
            detail_trends[f"level_{i}"] = power
            
        return {
            'main_trend': trend,
            'detail_trends': detail_trends
        }
    
    def denoise(self, coeffs=None, threshold=0.1):
        """
        Denoise data using wavelet thresholding.
        
        Args:
            coeffs: Optional pre-computed wavelet coefficients
            threshold: Threshold for coefficient removal
            
        Returns:
            list: Denoised data
        """
        if coeffs is None:
            coeffs = self.transform()
            
        if coeffs is None:
            return None
        
        try:
            import pywt
            import copy
            
            # Deep copy coefficients to avoid modifying originals
            denoised_coeffs = copy.deepcopy(coeffs)
            
            # Apply thresholding to detail coefficients
            for i in range(1, len(denoised_coeffs)):
                # Calculate threshold based on detail level
                level_threshold = threshold / (2 ** (i-1))
                
                # Apply threshold to coefficients
                denoised_coeffs[i] = pywt.threshold(
                    denoised_coeffs[i],
                    level_threshold * np.max(np.abs(denoised_coeffs[i])),
                    mode='soft'
                )
            
            # Reconstruct signal from denoised coefficients
            denoised_data = pywt.waverec(denoised_coeffs, self.wavelet)
            
            return denoised_data
        except ImportError:
            print("PyWavelets not installed. Install with 'pip install PyWavelets'")
            return None


class BayesianConfidenceScorer:
    """
    Calculate confidence scores for signals using Bayesian methods.
    """
    
    def __init__(self, prior_accuracy=0.5, smoothing=10):
        """
        Initialize with prior accuracy belief and smoothing factor.
        
        Args:
            prior_accuracy: Initial belief about signal accuracy (0-1)
            smoothing: Controls how quickly scores adapt to new data
        """
        self.prior_accuracy = prior_accuracy
        self.smoothing = smoothing
        self.signal_history = []  # (signal, was_correct) pairs
        
    def record_signal_result(self, signal, was_correct):
        """
        Record whether a signal led to a profitable trade.
        
        Args:
            signal: The original signal
            was_correct: Whether the signal led to a profitable trade
        """
        self.signal_history.append((signal, was_correct))
        
        # Keep history manageable
        if len(self.signal_history) > 1000:
            self.signal_history = self.signal_history[-1000:]
    
    def calculate_confidence(self, signal, context=None):
        """
        Calculate confidence score for a signal.
        
        Args:
            signal: The signal to score
            context: Optional context dict (regime, market conditions, etc.)
            
        Returns:
            float: Confidence score between 0-1
        """
        # Start with prior
        confidence = self.prior_accuracy
        
        # Not enough history to adjust
        if len(self.signal_history) < 5:
            return confidence
            
        # Count similar signals and their success rate
        similar_signals = 0
        correct_signals = 0
        
        for past_signal, was_correct in self.signal_history:
            # Determine similarity based on signal type and context
            similarity = self._calculate_similarity(signal, past_signal, context)
            
            if similarity > 0.5:  # Similarity threshold
                similar_signals += similarity
                if was_correct:
                    correct_signals += similarity
        
        # Apply Bayesian update if we have enough similar signals
        if similar_signals >= 1:
            # Accuracy of similar signals with smoothing
            accuracy = (correct_signals + self.prior_accuracy * self.smoothing) / (similar_signals + self.smoothing)
            confidence = accuracy
            
        return confidence
        
    def _calculate_similarity(self, signal1, signal2, context=None):
        """
        Calculate similarity between two signals.
        
        Args:
            signal1: First signal
            signal2: Second signal
            context: Optional context information
            
        Returns:
            float: Similarity score (0-1)
        """
        # Basic similarity: same signal type
        if signal1.signal_type == signal2.signal_type:
            similarity = 1.0
        else:
            similarity = 0.0
            
        # If context provided, adjust based on regime similarity
        if context and 'regime' in context:
            current_regime = context['regime']
            # Check if we stored regime info in signal metadata
            past_regime = signal2.metadata.get('regime') if hasattr(signal2, 'metadata') else None
            
            if past_regime is not None and past_regime != current_regime:
                # Different regimes reduce similarity
                similarity *= 0.5
                
        return similarity


class SignalProcessor:
    """
    Coordinates signal processing operations including filtering, 
    transformation, and confidence scoring.
    """
    
    def __init__(self, config=None):
        """
        Initialize with configuration.
        
        Args:
            config: Configuration dictionary or object
        """
        self.config = config or {}
        self.filters = {}
        self.transforms = {}
        self.confidence_scorer = None
        
        # Initialize components based on configuration
        self._initialize_components()
        
    def _initialize_components(self):
        """Initialize signal processing components from configuration."""
        # Extract configuration settings
        if hasattr(self.config, 'get'):
            # ConfigManager object
            use_filtering = self.config.get('signals.processing.use_filtering', False)
            filter_type = self.config.get('signals.processing.filter_type', 'moving_average')
            window_size = self.config.get('signals.processing.window_size', 5)
            use_transformations = self.config.get('signals.processing.use_transformations', False)
            use_confidence = self.config.get('signals.confidence.use_confidence_score', False)
        else:
            # Dictionary
            signals_config = self.config.get('signals', {})
            processing_config = signals_config.get('processing', {})
            confidence_config = signals_config.get('confidence', {})
            
            use_filtering = processing_config.get('use_filtering', False)
            filter_type = processing_config.get('filter_type', 'moving_average')
            window_size = processing_config.get('window_size', 5)
            use_transformations = processing_config.get('use_transformations', False)
            use_confidence = confidence_config.get('use_confidence_score', False)
        
        # Initialize filters
        if use_filtering:
            if filter_type == 'moving_average':
                self.filters['default'] = MovingAverageFilter(window_size)
            elif filter_type == 'exponential':
                self.filters['default'] = ExponentialFilter(0.2)
            elif filter_type == 'kalman':
                self.filters['default'] = KalmanFilter()
                
        # Initialize transforms
        if use_transformations:
            self.transforms['wavelet'] = WaveletTransform()
            
        # Initialize confidence scorer
        if use_confidence:
            self.confidence_scorer = BayesianConfidenceScorer()
            
    def process_signal(self, signal, context=None):
        """
        Process a signal through filtering, transformation, and confidence scoring.
        
        Args:
            signal: The signal to process
            context: Optional context information
            
        Returns:
            Signal: Processed signal
        """
        processed_signal = signal
        
        # Apply filters
        if self.filters and 'default' in self.filters:
            processed_signal = self.filters['default'].filter(processed_signal)
            
        # Apply transforms (if they affect the signal directly)
        # Most transforms are used for analytics, not signal modification
        
        # Apply confidence scoring
        if self.confidence_scorer:
            confidence = self.confidence_scorer.calculate_confidence(processed_signal, context)
            processed_signal.confidence = confidence
            processed_signal.metadata['confidence_scored'] = True
            
        return processed_signal
    
    def process_price_data(self, prices, symbol='default'):
        """
        Process price data for additional insights.
        
        Args:
            prices: List or array of price data
            symbol: Instrument symbol
            
        Returns:
            dict: Analysis results
        """
        results = {}
        
        # Apply wavelet transform if available
        if 'wavelet' in self.transforms:
            wavelet = self.transforms['wavelet']
            
            # Add prices to history
            for price in prices:
                wavelet.add_price(price)
                
            # Perform transform
            coeffs = wavelet.transform()
            
            if coeffs is not None:
                # Analyze trend
                trend_analysis = wavelet.analyze_trend(coeffs)
                results['trend_analysis'] = trend_analysis
                
                # Denoise data
                denoised_prices = wavelet.denoise(coeffs)
                if denoised_prices is not None:
                    results['denoised_prices'] = denoised_prices
        
        return results
    
    def record_trade_result(self, signal, was_profitable):
        """
        Record trade result for confidence model learning.
        
        Args:
            signal: The signal that led to the trade
            was_profitable: Whether the trade was profitable
        """
        if self.confidence_scorer:
            self.confidence_scorer.record_signal_result(signal, was_profitable)
    
    def reset(self):
        """Reset all signal processing components."""
        # Reset filters
        for filter_obj in self.filters.values():
            filter_obj.reset()
            
        # Reset transforms if they have state
        for transform in self.transforms.values():
            if hasattr(transform, 'reset'):
                transform.reset()
