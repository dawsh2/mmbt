from enum import Enum, auto
from datetime import datetime
import pandas as pd
from typing import Optional, Dict, Any, List

class SignalType(Enum):
    """Enumeration of different signal types."""
    BUY = 1
    SELL = -1
    NEUTRAL = 0

class Signal:
    """
    Class representing a trading signal.
    
    This class provides a standardized structure for trading signals
    generated by rules and strategies in the trading system.
    """
    
    def __init__(self, 
                 timestamp: datetime, 
                 type: SignalType, 
                 price: float, 
                 rule_id: Optional[str] = None,
                 confidence: float = 1.0,
                 metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize a trading signal.
        
        Args:
            timestamp: When the signal was generated
            type: Type of signal (BUY, SELL, NEUTRAL)
            price: Price at which the signal was generated
            rule_id: Optional identifier of the rule that generated the signal
            confidence: Confidence level of the signal (0.0 to 1.0)
            metadata: Additional signal-specific data
        """
        self.timestamp = timestamp
        self.type = type
        self.price = price
        self.rule_id = rule_id
        self.confidence = min(max(confidence, 0.0), 1.0)  # Ensure between 0 and 1
        self.metadata = metadata or {}
    
    @classmethod
    def from_numeric(cls, timestamp: datetime, signal_value: int, price: float, 
                     rule_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None):
        """
        Create a Signal object from a numeric signal value (-1, 0, 1).
        
        Args:
            timestamp: Signal timestamp
            signal_value: Numeric signal value (-1, 0, 1)
            price: Price at signal generation
            rule_id: Optional rule identifier
            metadata: Additional signal data
        
        Returns:
            Signal: A new Signal object
        """
        if signal_value == 1:
            signal_type = SignalType.BUY
        elif signal_value == -1:
            signal_type = SignalType.SELL
        else:
            signal_type = SignalType.NEUTRAL
            
        return cls(timestamp, signal_type, price, rule_id, 1.0, metadata)
    
    @classmethod
    def from_dict(cls, signal_dict: Dict[str, Any]):
        """
        Create a Signal object from a dictionary (for backward compatibility).
        
        Args:
            signal_dict: Dictionary containing signal data
        
        Returns:
            Signal: A new Signal object
        """
        timestamp = signal_dict["timestamp"]
        numeric_signal = signal_dict["signal"]
        price = signal_dict["price"]
        
        # Extract any additional data as metadata
        metadata = {k: v for k, v in signal_dict.items() 
                    if k not in ["timestamp", "signal", "price"]}
        
        return cls.from_numeric(timestamp, numeric_signal, price, metadata=metadata)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the Signal to a dictionary representation.
        
        Returns:
            dict: Dictionary representation of the signal
        """
        result = {
            "timestamp": self.timestamp,
            "signal": self.type.value,
            "price": self.price,
        }
        
        if self.rule_id:
            result["rule_id"] = self.rule_id
            
        if self.confidence != 1.0:
            result["confidence"] = self.confidence
            
        # Add any metadata
        result.update(self.metadata)
        
        return result
    
    def get_numeric_signal(self) -> int:
        """
        Get the numeric representation of the signal type.
        
        Returns:
            int: 1 for BUY, -1 for SELL, 0 for NEUTRAL
        """
        return self.type.value
    
    def __str__(self) -> str:
        """String representation of the signal."""
        signal_type_name = self.type.name
        return f"Signal({signal_type_name}, {self.timestamp}, ${self.price:.2f})"
    
    def __repr__(self) -> str:
        """Detailed representation of the signal."""
        return (f"Signal(timestamp={self.timestamp}, type={self.type.name}, "
                f"price={self.price:.2f}, rule_id={self.rule_id}, "
                f"confidence={self.confidence:.2f})")


class SignalCollection:
    """
    Collection of signals with utility methods for aggregation and analysis.
    
    This class manages multiple signals, particularly useful for combining
    signals from different rules in a strategy.
    """
    
    def __init__(self, signals: Optional[List[Signal]] = None):
        """
        Initialize a signal collection.
        
        Args:
            signals: Optional initial list of signals
        """
        self.signals = signals or []
    
    def add(self, signal: Signal):
        """
        Add a signal to the collection.
        
        Args:
            signal: Signal to add
        """
        self.signals.append(signal)
    
    def clear(self):
        """Clear all signals from the collection."""
        self.signals = []
    
    def get_signals_by_type(self, signal_type: SignalType) -> List[Signal]:
        """
        Get all signals of a specific type.
        
        Args:
            signal_type: Type of signals to retrieve
        
        Returns:
            list: List of matching signals
        """
        return [s for s in self.signals if s.type == signal_type]
    
    def get_signals_by_rule(self, rule_id: str) -> List[Signal]:
        """
        Get all signals generated by a specific rule.
        
        Args:
            rule_id: ID of the rule
        
        Returns:
            list: List of matching signals
        """
        return [s for s in self.signals if s.rule_id == rule_id]
    
    def get_weighted_consensus(self) -> SignalType:
        """
        Calculate a weighted consensus signal based on signal confidences.
        
        Returns:
            SignalType: The consensus signal type
        """
        if not self.signals:
            return SignalType.NEUTRAL
        
        weighted_sum = sum(s.get_numeric_signal() * s.confidence for s in self.signals)
        avg = weighted_sum / len(self.signals)
        
        if avg > 0.2:  # Threshold for buy
            return SignalType.BUY
        elif avg < -0.2:  # Threshold for sell
            return SignalType.SELL
        else:
            return SignalType.NEUTRAL
    
    def to_dataframe(self) -> pd.DataFrame:
        """
        Convert the signal collection to a pandas DataFrame.
        
        Returns:
            pd.DataFrame: DataFrame containing all signals
        """
        data = []
        for signal in self.signals:
            row = {
                'timestamp': signal.timestamp,
                'type': signal.type.name,
                'numeric_signal': signal.get_numeric_signal(),
                'price': signal.price,
                'rule_id': signal.rule_id,
                'confidence': signal.confidence
            }
            # Add any metadata as columns
            for k, v in signal.metadata.items():
                row[k] = v
            data.append(row)
            
        return pd.DataFrame(data)
    
    def __len__(self) -> int:
        """Get the number of signals in the collection."""
        return len(self.signals)
    
    def __getitem__(self, index) -> Signal:
        """Get a signal by index."""
        return self.signals[index]
    
    def __iter__(self):
        """Iterate through signals."""
        return iter(self.signals)
